<html>
  <head>
    <style>
      html, body { 
        background-color:#000;
        margin: 0;
        padding: 0;
        height: 100%;
        overflow: hidden !important;  
      }
      .instructions {
        background-color:#222;
        height: 22px;
        width: 10%;
        border-radius: 5px;
      }
    </style>
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@latest/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@latest/examples/jsm/"
      }
    }
    </script>
    <script type="module">

      // Import Three.js utilities
      import * as THREE from 'three';
      import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
      
      // Three.js objects for rendering
      var renderer, controls, scene, camera;
      
      // Global editor constants
      const vertDetectDistance = 0.5;
      const defaultShape = [new THREE.Vector2(-5, 5),
                            new THREE.Vector2(5, 5),
                            new THREE.Vector2(5, -5),
                            new THREE.Vector2(-5, -5)];
      const activeShapeMaterial = new THREE.MeshBasicMaterial({ color: 0xff69b4 });
      const activePointsMaterial = new THREE.PointsMaterial({ color: 0xffff00 });
      //const centersMaterial = new THREE.PointsMaterial({ color: 0xff0000 });
      
      // Color picker
      const colorPicker = document.getElementById("ColorPicker");
      colorPicker.addEventListener("input", (event) => {
        const selectedColor = colorPicker.value;
        activeElement.color = new THREE.Color(selectedColor);
      });
      
      // Storing all scene elements
      var elements = new Array();
      var edit_origin;
      
      // Managing the current active object and point;
      var activeElement, activePoints, aeid = -1, apid = -1;
      
      //TODO: Fix
      function updateOrigins(){
        if(originsObject != null){
          scene.remove(originsObject);
        }
        var oShape = new THREE.BufferGeometry(origins);
        originsObject = new THREE.Points(oShape);
        originsObject.position.set(0,0,0.1);
        scene.add(originsObject);
      }
      
      // Utility for getting a raycast from the active camera
      function getCameraRaycaster(e){
        var pixel_coords = new THREE.Vector2( e.clientX, e.clientY );
        var vp_coords = new THREE.Vector2( 
                            ( pixel_coords.x / window.innerWidth ) * 2 - 1,  //X
                           -( pixel_coords.y / window.innerHeight ) * 2 + 1) // Y

        var vp_coords_near = new THREE.Vector3( vp_coords.x, vp_coords.y, 0);
        var raycaster = new THREE.Raycaster();
        raycaster.setFromCamera(vp_coords_near, camera);
        return raycaster;
      }
      
      // Detects where in the scene the user has clicked
      function getPointProjected(e, plane){
        var raycaster = getCameraRaycaster(e);
        var intersects = raycaster.intersectObject(plane);
        return new THREE.Vector2(intersects[0].point.x, intersects[0].point.y);
      }
      
      // Finds the clicked object and sets it active
      function getClickedObject(e){
        var raycaster = getCameraRaycaster(e);
        var j, intersects;
        for(var i = 0; i < elements.length; i++){
          j = (aeid + i + 1)%elements.length;
          intersects = raycaster.intersectObject(elements[j].sceneObject);
          if(intersects.length > 0){
            setActiveElement(j);
            return false;
          }
        }
        return true;
      }
      
      function setActiveElement(id){
        if(aeid != -1){
          drawShape(aeid, false);
          scene.remove(activePoints);
          aeid = -1;
        }
        if(id != -1){
          aeid = id;
          drawShape(aeid, true);
        }
      }
      
      function drawShape(id, activate){
        if(id != -1){
          // Choose the ID of the shape we want to draw
          var targetElement = elements[id];
          
          // Remove existing scene objects
          scene.remove(targetElement.sceneObject);
          
          // Remove previous shape
          var material = activate ? activeShapeMaterial : new THREE.MeshBasicMaterial({ color: targetElement.color });
          targetElement.sceneObject = new THREE.Mesh(targetElement.geometry, material);
          targetElement.sceneObject.position.set(targetElement.origin.x, targetElement.origin.y, activate? 0.05:0);
          scene.add(targetElement.sceneObject);
          
          if(activate){
            activeElement = targetElement;
            activePoints = new THREE.Points(activeElement.geometry, activePointsMaterial);
            activePoints.position.set(targetElement.origin.x, targetElement.origin.y, 0.1);
            scene.add(activePoints);
          }
        }
      }
      
      //TODO: Rework to be "Change mesh" or something
      function redrawShape(pointID, delta, setActive = false){
        activeElement.points[pointID] += delta;
        activeElement.geometry = new THREE.ShapeGeometry(new THREE.Shape(activeElement.points));
      }
      
      //TODO: Returns the nearest point within the point detection radius
      function nearestPoint(origin, shapeOrigin, points){
        var closest = -1;
        var cDistance = vertDetectDistance;
        for(var i = 0; i < points.length; i++){
          var local = shapeOrigin.clone().add(points[i]);
          var dist = origin.distanceTo(local);
          if(dist < cDistance){
            closest = i;
            cDistance = dist;
          }
        }
        console.log(closest);
        return closest;
      }
      
      //TODO: Fix
      function addPoint(pos){
        var points = activeElement.points;
        
        var lPos = pos.clone().sub(activeElement.origin);
        
        var iPoint = 0;
        var prevPoint = points[points.length-1];
        var nextPoint = points[0];
        var mDistance = lPos.distanceTo(prevPoint) + lPos.distanceTo(nextPoint);
        var cDistance = mDistance;
        for(var i = 1; i < activeElement.points.length; i++){
          cDistance -= lPos.distanceTo(prevPoint);
          prevPoint = nextPoint;
          nextPoint = points[i];
          cDistance += lPos.distanceTo(nextPoint);
          if(cDistance < mDistance){
            mDistance = cDistance;
            iPoint = i/2;
          }
        }
        activeElement.points = activeElement.points.slice(0, iPoint).concat(lPos).concat(activeElement.points.slice(iPoint));
        drawShape(aeid, true);
      }
      
      // TODO: Adapt to work with the new thing
      function removePoint(pointID){
        console.log(pointID);
        console.log(activeElement.points);
        activeElement.points = activeElement.points.slice(0, pointID).concat(activeElement.points.slice(pointID+1));
        console.log(activeElement.points);
        setActiveElement(aeid);
      }
      
      // Adds a board element to the scene
      function addElement(pos){
        // Create the new element
        var newElement = new Object();
        newElement.points = structuredClone(defaultShape);
        newElement.origin = pos;
        newElement.geometry = new THREE.ShapeGeometry(new THREE.Shape(newElement.points));
        newElement.color = 0xffffff;
        newElement.sceneObject = null;
        elements.push(newElement);
        
        // Draw the shape of the new element in the scene
        setActiveElement(elements.length-1);
      }

      window.onload = function() {

        // Create scene
        scene = new THREE.Scene();

        // create renderer and setup the canvas
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize( window.innerWidth, window.innerHeight );
        document.body.appendChild( renderer.domElement );
        
        // setup lights
        var ambientLight = new THREE.AmbientLight();
        scene.add( ambientLight );

        var light = new THREE.DirectionalLight( 0xffffff, 5.0 );
        light.position.set( 0, 100, 0 );
        scene.add( light );

        // setup camera
        var fov = 45;
        var ratio = window.innerWidth / window.innerHeight;
        var zNear = 1;
        var zFar = 10000;
        camera = new THREE.PerspectiveCamera( fov, ratio, zNear, zFar );
        camera.position.set(0, 0, 100);

        // interaction
        controls = new OrbitControls( camera, renderer.domElement );
        controls.mouseButtons = { MIDDLE: THREE.MOUSE.PAN };

        // The invisible plane for click detection
        var pGeometry = new THREE.PlaneGeometry( 10000, 10000 );
        var pMaterial = new THREE.MeshBasicMaterial( {
          visible: false
        });
        var invisible_plane = new THREE.Mesh( pGeometry, pMaterial );
        scene.add( invisible_plane );

        // Active element
        activeElement = null;

        renderer.domElement.onmousedown = function( e ){
          var int_point = getPointProjected(e, invisible_plane);
          
          if(e.button == 0){
            if(e.ctrlKey){
              addElement(int_point);
            }
            else if(e.shiftKey){
              addPoint(int_point);
            }
            else{
              var np = nearestPoint(int_point, activeElement.origin, activeElement.points);
              if(np != -1) {
                edit_origin = int_point;
                apid = np;
              }
              else{
                getClickedObject(e);
              }
            }
          }
          else if(e.button == 2){
            var np = nearestPoint(int_point, activeElement.origin, activeElement.points);
              if(np != -1) {
                removePoint(np);
              }
          }
        };
        
        renderer.domElement.onmousemove = function(e){
          if(apid != -1){
            var int_point = getPointProjected(e, invisible_plane);
            var delta = int_point.clone().sub(edit_origin);
            console.log(delta);
            
            activeElement.points[apid] = delta.clone().add(activeElement.points[apid]);
            elements[aeid] = activeElement;
            
            edit_origin = int_point;
            
            drawShape(aeid, true);
          }
        }
        
        renderer.domElement.onmouseup = function( e ){
          edit_origin = null;
          apid = -1;
        }
        
        window.onkeydown = function( e ){
          if(e.key == 'c'){
            colorPicker.style.display = (colorPicker.style.display=="block") ? "none" : "block";
          }
        }
        // call animation/rendering loop
        animate();
      };

      function animate() {
        requestAnimationFrame( animate );
        controls.update();
        renderer.render( scene, camera );
      };
    </script>
  </head>
  <body>
    <input type="color" id="ColorPicker" style="display: none" value="#ffffff">
  </body>
</html>
